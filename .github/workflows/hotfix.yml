name: hotfix

on:
  issue_comment:
    types: [created]

permissions:
  contents: write
  pull-requests: write
  actions: write

jobs:
  cherry-pick:
    if: github.event.issue.pull_request && contains(github.event.comment.body, '/perform-hotfix')
    runs-on: ubuntu-latest
    steps:
      - name: Check team membership
        uses: tspascoal/get-user-teams-membership@v2
        id: actorTeams
        with:
          username: ${{ github.actor }}
          GITHUB_TOKEN: ${{ secrets.PAT }}
      - name: Check if user belongs to team
        run: |
          if [[ "${{ steps.actorTeams.outputs.teams }}" == *"infra-release-managers"* ]]; then
            echo "User belongs to team"
          else
            echo "User does not belong to team"
            exit 1
          fi
      - name: Checkout code
        uses: actions/checkout@v2
        with:
          fetch-depth: 0
          ref: 'tfdev' # Make sure we checkout the branch where PR gets merged
      - name: Extract text after /perform-hotfix
        id: input
        run: |
          branch=$(cat $GITHUB_EVENT_PATH | jq -r '.comment.body | capture("/perform-hotfix\\s*\\b(?<text1>[^\\s]+)(?:\\s+(?<text2>[^\\s]+))?\\b") | .text1')
          tag=$(cat $GITHUB_EVENT_PATH | jq -r '.comment.body | capture("/perform-hotfix\\s*\\b(?<text1>[^\\s]+)(?:\\s+(?<text2>[^\\s]+))?\\b") | if .text2 then .text2 else "" end')
          if [ -z "$branch" ]; then
            branch="production"
          fi
          if [ -n "$tag" ]; then
            newTag=$tag
          else
            # Fetch all tags from remote
            git fetch --tags
            # Get the latest tag name
            latestTag=$(git tag --sort=-v:refname | head -n 1)
            # Extract major, minor, and patch versions
            majorVersion=$(echo $latestTag | cut -d. -f1)
            minorVersion=$(echo $latestTag | cut -d. -f2)
            patchVersion=$(echo $latestTag | cut -d. -f3)

            # Increment the patch version
            newPatchVersion=$((patchVersion + 1))

            # Construct the new tag name
            newTag="$majorVersion.$minorVersion.$newPatchVersion"
          fi
          echo "branch=$branch"
          echo "tag=$newTag"
          echo "branch=$branch" >> $GITHUB_OUTPUT
          echo "tag=$newTag" >> $GITHUB_OUTPUT
      - name: Authenticate GH CLI
        run: gh auth login --with-token <<< ${{ secrets.GITHUB_TOKEN }}

      - name: Check if PR is merged
        id: check
        run: |
          PR_MERGED=$(gh pr view ${{ github.event.issue.number }} --json state -q '.state')
          echo "::set-output name=merged::$PR_MERGED"

      - name: Get squash merge commit ID
        id: commit_id
        run: |
          if [[ "${{ steps.check.outputs.merged }}" == "MERGED" ]]; then
            COMMIT_ID=$(gh pr view ${{ github.event.issue.number }} --json mergeCommit -q '.mergeCommit.oid')
            echo "::set-output name=id::$COMMIT_ID"
          else
            echo "PR not merged"
            exit 1
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Set Git identity
        run: |
          git config --global user.name "${{ github.actor }}"
          git config --global user.email "${{ github.actor }}@users.noreply.github.com"

      - name: Checkout hotfix branch
        run: git checkout ${{ steps.input.outputs.branch }}

      - name: Cherry-pick commit
        run: git cherry-pick ${{ steps.commit_id.outputs.id }}

      - name: Push changes
        uses: ad-m/github-push-action@master
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          branch: ${{ steps.input.outputs.branch }}
        env:
          GIT_COMMITTER_NAME: ${{ github.actor }}
          GIT_COMMITTER_EMAIL: ${{ github.actor }}@users.noreply.github.com
      - name: Trigger the stage workflow
        id: stage_trigger
        run: |
          gh workflow run stage -R ${{ github.repository }} --ref tfdev -F tag=${{ steps.input.outputs.tag }} -F ref=${{ steps.input.outputs.branch }}
          sleep 3
          url=$(gh run list --workflow=stage.yml --json url --jq '.[0].url')
          echo "url=$url" >> $GITHUB_OUTPUT
        env:
          GITHUB_TOKEN: ${{ secrets.PAT }}
      - name: Add comment to PR
        uses: actions/github-script@v3
        with:
          github-token: ${{secrets.GITHUB_TOKEN}}
          script: |
            const issueComment = `The new tag [${{ steps.input.outputs.tag }}](https://github.com/${{ github.repository }}/releases/tag/${{ steps.input.outputs.tag }}) has been created, the stage workflow has been triggered and can be seen [here](${{ steps.stage_trigger.outputs.url }}).`
            github.issues.createComment({
              issue_number: ${{ github.event.issue.number }},
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: issueComment
            })
      - name: Get SLACK USER ID
        id: slack_userid
        run: |
          SLACK_USERNAMES='${{ vars.SLACK_USERNAMES }}'
          echo "$SLACK_USERNAMES" > slack_usernames.json
          userid=$(cat slack_usernames.json | jq -r '.["${{ github.actor }}"] // "${{ github.actor }}"')
          echo "userid=$userid" >> $GITHUB_OUTPUT
      - name: Post Success to a Slack channel
        id: slack
        uses: slackapi/slack-github-action@v1.24.0
        with:
          channel-id: ${{ secrets.CHANNEL_ID }}
          slack-message: 'HOTFIX(<https://github.com/${{ github.repository }}/pull/${{ github.event.issue.number }}|#${{ github.event.issue.number }}>): Tag <https://github.com/${{ github.repository }}/releases/tag/${{ steps.input.outputs.tag }}|${{ steps.input.outputs.tag }}> has been created by <@${{ steps.slack_userid.outputs.userid }}>, the stage workflow has been triggered and can be seen <${{ steps.stage_trigger.outputs.url }}|here>.'
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_TOKEN }}